// Generated by CoffeeScript 1.6.3
(function() {
  var Array, Base, EventEmitter, RArray, REdit, RValue, Scuttlebucket, Scuttlebutt, Value, between, dutyOfSubclass, filter, hat, order, ss, through, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  Scuttlebucket = require('scuttlebucket');

  Scuttlebutt = require('scuttlebutt');

  filter = require('scuttlebutt/util').filter;

  through = require('through');

  between = require('between');

  RArray = require('r-array');

  RValue = require('r-value');

  REdit = require('r-edit');

  util = require('util');

  hat = require('hat');

  ss = require('stream-serializer');

  order = function(a, b) {
    return between.strord(a[1], b[1]) || between.strord(a[2], b[2]);
  };

  dutyOfSubclass = function(name) {
    return function() {
      throw new Error("" + this.constructor.name + "." + name + " must be implemented");
    };
  };

  Base = (function(_super) {
    __extends(Base, _super);

    function Base() {
      _ref = Base.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Base.types = {};

    Base.register = function(type) {
      return this.types[type.name.toLowerCase()] = type;
    };

    Base.create = function() {
      var args, name;
      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.types[name], args, function(){});
    };

    Base.prototype.pipe = function(dest) {
      this.createReadStream().pipe(dest.createWriteStream());
      return dest;
    };

    Base.prototype.map = function() {
      var args, fn, mapper, newLive;
      fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      newLive = new this.constructor;
      mapper = function(update) {
        return newLive.mapper.apply(newLive, [update, fn].concat(__slice.call(args)));
      };
      this.createReadStream().pipe(ss.json(through(function(update) {
        var res;
        res = mapper(update);
        console.log(res);
        return this.queue(res);
      }))).pipe(newLive.createWriteStream());
      return newLive;
    };

    Base.prototype.creationArgs = dutyOfSubclass('creationArgs');

    Base.prototype.mapper = dutyOfSubclass('mapper');

    Base.prototype.applyUpdate = dutyOfSubclass('applyUpdate');

    Base.prototype.history = dutyOfSubclass('history');

    return Base;

  })(Scuttlebutt);

  Array = (function(_super) {
    __extends(Array, _super);

    function Array() {
      var val, vals, _i, _len,
        _this = this;
      vals = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Array.__super__.constructor.call(this);
      this._sb = new RArray;
      this._db = {};
      this._hist = {};
      this._rack = hat.rack();
      this.length = new Value(0);
      this._updateBuffer = {};
      this._sbKeys = {};
      this._dbKeys = {};
      this._sb.on('update', function(rawUpdate) {
        var key, sbKey, update;
        update = {};
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          update[key] = _this._db[key];
        }
        _this.emit('update', update);
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          if ((key != null) && (update[key] != null)) {
            if (_this._updateBuffer[key] != null) {
              _this.emit('update', _this._sb.indexOfKey(sbKey), update[key], key, sbKey);
            } else {
              _this.emit('insert', _this._sb.indexOfKey(sbKey), update[key], key, sbKey);
              _this.length.set(_this.length.get() + 1);
            }
            _this._updateBuffer[key] = update[key];
          } else {
            key = _this._dbKeys[sbKey];
            if (_this._updateBuffer[key] != null) {
              _this.emit('remove', _this._sb.indexOfKey(sbKey), _this._updateBuffer[key], key, sbKey);
              delete _this._updateBuffer[key];
              delete _this._sbKeys[key];
              delete _this._dbKeys[sbKey];
              process.nextTick((function(key) {
                return delete this._db[key];
              }).bind(_this, key));
              _this.length.set(_this.length.get() - 1);
            } else {

            }
          }
        }
        for (sbKey in rawUpdate) {
          key = rawUpdate[sbKey];
          if (key != null) {
            _this._sbKeys[key] = sbKey;
            _this._dbKeys[sbKey] = key;
          } else {
            delete _this._dbKeys[sbKey];
          }
        }
      });
      this._sb.on('_update', function(update) {
        console.log('Array._sb updated');
        return _this.emit('_update', [['a', update[0]], update[1], update[2]]);
      });
      for (_i = 0, _len = vals.length; _i < _len; _i++) {
        val = vals[_i];
        this.push(val);
      }
    }

    Array.prototype.creationArgs = function() {
      return [];
    };

    Array.mapCreationArgs = function(fn, args) {
      return [];
    };

    Array.prototype._genId = function() {
      return this._rack();
    };

    Array.prototype._register = function(val, key, update) {
      var _this = this;
      if (key == null) {
        key = this._genId();
      }
      if (update == null) {
        update = true;
      }
      if (update) {
        this.localUpdate(['d', key, val.constructor.name.toLowerCase(), val.creationArgs()]);
      }
      this._db[key] = val;
      val.on('_update', function(update) {
        if (_this._db[key] === val) {
          return _this.emit('_update', [['c', key, update[0]], update[1], update[2]]);
        }
      });
      return key;
    };

    Array.prototype._setIndex = function(index, key) {
      return this._sb.set(this._sb.keys[index], key);
    };

    Array.prototype.push = function(val) {
      var key;
      key = this._register(val);
      this._sb.push(key);
      return this;
    };

    Array.prototype.unshift = function(val) {
      var key;
      key = this._register(val);
      this._sb.unshift(key);
      return this;
    };

    Array.prototype.get = function(index) {
      return this._db[this._sb.get(this._sb.keys[index])];
    };

    Array.prototype.pop = function() {
      var key;
      key = this._sb.pop();
      return this._db[key];
    };

    Array.prototype.shift = function() {
      var key;
      key = this._sb.shift();
      return this._db[key];
    };

    Array.prototype.forEach = function(fn) {
      var i, _i, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref1 = this.length.get() - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push(fn(this.get(i), i));
      }
      return _results;
    };

    Array.prototype.each = function(fn) {
      return this.forEach(fn);
    };

    Array.prototype.mapper = function(update, fn, subArgs) {
      var childUpdate, data, _ref1;
      if (subArgs == null) {
        subArgs = [];
      }
      if (util.isArray(update)) {
        data = update[0];
        switch (data[0]) {
          case 'c':
            childUpdate = [data[2], update[1], update[2]];
            childUpdate = (_ref1 = this._db[data[1]]).mapper.apply(_ref1, [fn].concat(__slice.call(subArgs), [childUpdate]));
            return [['c', data[1], childUpdate[0]], childUpdate[1], childUpdate[2]];
          case 'd':
            return [['d', data[1], data[2], Base.types[data[2]].mapCreationArgs(fn, data[3])], update[1], update[2]];
          default:
            return update;
        }
      } else {
        return update;
      }
    };

    Array.prototype.history = function(sources) {
      var hist, key, update, val, _ref1, _ref2;
      hist = this._sb.history(sources).map(function(update) {
        return [['a', update[0]], update[1], update[2]];
      });
      _ref1 = this._hist;
      for (key in _ref1) {
        update = _ref1[key];
        if (!~hist.indexOf(update) && filter(update, sources)) {
          hist.push(update);
        }
      }
      _ref2 = this._db;
      for (key in _ref2) {
        val = _ref2[key];
        hist = hist.concat(val.history(sources).map(function(update) {
          return [['c', key, update[0]], update[1], update[2]];
        }));
      }
      return hist.sort(order);
    };

    Array.prototype.applyUpdate = function(update) {
      var data;
      data = update[0];
      switch (data[0]) {
        case 'a':
          return this._sb.applyUpdate([data[1], update[1], update[2]]);
        case 'd':
          this._hist[data[1]] = update;
          if (this._db[data[1]] == null) {
            this._register(Base.create.apply(Base, [data[2]].concat(__slice.call(data[3]))), data[1], false);
          }
          this.emit('_register', data[1], this._db[data[1]]);
          return true;
        case 'c':
          if (this._db[data[1]] != null) {
            return this._db[data[1]]._update([data[2], update[1], update[2]]);
          }
      }
    };

    return Array;

  })(Base);

  Base.Array = Array;

  Base.register(Array);

  Value = (function(_super) {
    __extends(Value, _super);

    function Value(defaultVal, force) {
      var _this = this;
      if (force == null) {
        force = false;
      }
      Value.__super__.constructor.call(this);
      this._sb = new RValue;
      this._sb.on('update', function(data) {
        return _this.emit('update', data);
      });
      this._sb.on('_update', function(update) {
        return _this.emit('_update', [update[0], update[1], _this.id]);
      });
      if (defaultVal != null) {
        this.set(defaultVal);
      }
    }

    Value.prototype.creationArgs = function() {
      return [this.get()];
    };

    Value.mapCreationArgs = function(fn, args) {
      return [fn(args[0])];
    };

    Value.prototype.set = function(newValue) {
      if (this.get() !== newValue) {
        this._sb.set(newValue);
      }
      return this;
    };

    Value.prototype.get = function() {
      if (this._sb._history.length) {
        return this._sb.get();
      } else {
        return this.defaultVal;
      }
    };

    Value.prototype.mapper = function(update, fn) {
      return [fn(update[0]), update[1], update[2]];
    };

    Value.prototype.history = function(sources) {
      return this._sb.history(sources);
    };

    Value.prototype.applyUpdate = function(update) {
      return this._sb.applyUpdate(update);
    };

    return Value;

  })(Base);

  Base.Value = Value;

  Base.register(Value);

  module.exports = Base;

}).call(this);
